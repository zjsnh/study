# 程序地址空间

![image-20240721192025099](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240721192025099.png)

**先定义的变量陷入栈，也就是往下增长**

**堆栈相对而生**

为什么static变量不随着函数的销毁而销毁，只能在函数作用域里使用

<img src="C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240721192050365.png" alt="image-20240721192050365" style="zoom:50%;" />



虚拟地址才能实现

同一个变量，父子进程读取地址相同，但变量值不同

![image-20240721192724181](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240721192724181.png)

## 进程地址空间

![image-20240722104603756](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240722104603756.png)



**每一个进程都有自己的页表，通过自己的页表和虚拟地址映射到物理地址，从而找到存储的数据**





mmstruct

![image-20240722104526084](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240722104526084.png)

![image-20240722104541453](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240722104541453.png)

**系统对每一个进程分配相同大小的虚拟地址，而数据真实并不是存储在虚拟地址里，虚拟地址只是映射 key   ，每一个进程通过自己的页表，映射到真实的物理地址**

也就是说，父子进程变量就算虚拟地址一样，但是通过**自己的页表映射**，获取不同的值

![image-20240722105458359](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240722105458359.png)

虚拟地址空间可以对用户访问的时候，对该寻址操作进行审查，一旦有异常就会直接拦截，保护物理地址 

**同时页表在做 虚拟地址与物理地址映射时，还有一项对该数据的描述（r  w） 可写，可读**，**还有一项描述对应的代码和数据是否已经加载到内存**

![image-20240722112356145](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240722112356145.png)

如果没有加载到内存，就会触发缺页中断（写时拷贝也是），在磁盘或者重新开辟空间，写入后，再次运行



## 页表

**通过页表**

**进程管理只关心虚拟地址，而不与物理地址直接接触，当发生缺页中断时，只需要内存管理去获取或者拷贝需要的数据**

![image-20240722115707311](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240722115707311.png)