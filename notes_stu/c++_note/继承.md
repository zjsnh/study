# 继承

## 模板的分离编译

![image-20240515204848333](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515204848333.png)

但是对于其他不同类型的传参，仍然不可以，不好用

![image-20240515205737435](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515205737435.png)

类模板，可以直接把整个类实例化，但这不是长久之计、

我们可以将声明定义放到一个.h文件里，声明与定义分离就可以了

```C++
#include<iostream>
using namespace std;

template<class T>
T Add(const T& left, const T& right);

void func();

template<class T>
class Stack 
{
public:
	void Push(const T& x);
	void Pop();
private:
	T* _a = nullptr;
	int _top = 0;
	int _capacity = 0;
};

template<class T>
T Add(const T& left, const T& right)
{
	cout << "T Add(const T& left, const T& right)" << endl;
	return left + right;
}

void func()
{
	cout << "void func()" << endl;
}

template<class T>
void Stack<T>::Push(const T& x)
{
	cout << "void Stack<T>::Push(const T& x)" << endl;
}

template<class T>
void Stack<T>::Pop()
{
	cout << "void Pop()" << endl;
}
```

继承

![image-20240515212346314](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515212346314.png)

继承包括继承成员函数和成员

![image-20240515214520636](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515214520636.png)

![image-20240515215730660](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515215730660.png)

父类的私有成员无论什么方式继承都不可见，无论是在类里面还是直接调用，保护成员在类外面不可使用，类里面可以使用

class是默认私有继承 struct是公有继承

![image-20240515221140851](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515221140851.png)

![image-20240515221416493](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515221416493.png)

仅限于子类对象赋值给父类对象  

## 指定作用域

![image-20240515222427285](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515222427285.png)

父类和子类可以拥有同名成员

![image-20240515222539388](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515222539388.png)

  函数重载要求在同一作用域，父类和子类成员不在同一作用域

```C++
class A
{
public:
 void fun()
 {
 cout << "func()" << endl;
 }
};
class B : public A
{
public:
 void fun(int i)
 {
 A::fun();
 cout << "func(int i)->" <<i<<endl;
 }
};
```

两个func构成隐藏

![image-20240515222958408](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515222958408.png)

ps：尽量不要定义同名成员

![image-20240515223257008](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515223257008.png)

派生类的构造函数需要分成两个部分，初始化父类的成员，需要调用父类的构造函数，基类成员不写构造函数，构造时，父类的成员会调用父类的成员函数，拷贝构造也是这样

![image-20240515223443967](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515223443967.png)

写构造函数的时候们需要单独将父类对象单独看成一个整体，去调用父类的构造和拷贝构造，而这时候，父类的拷贝构造需要父类的对象

![image-20240515223825138](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515223825138.png)

兼容规则起作用

![image-20240515223859968](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515223859968.png)

但是构成隐藏，我们就需要显示去调用父类赋值构造函数，指定！！

![image-20240515224035499](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515224035499.png)

```c++
Student(const char* name, int id)
		:_id(id)
		, Person(name)
	{
		cout << "Student(const char* name, int id)" << endl;
	}

	Student(const Student& s)
		:Person(s)
		,_id(s._id)
	{
		cout << "Student(const Student& s)" << endl;
	}

	Student& operator=(const Student& s)
	{
		if (&s != this)
		{
			Person::operator=(s);
			_id = s._id;
		}

		cout << "Student& operator=(const Student& s)" << endl;

		return *this;
	}
```

## 析构函数：

![image-20240515224303227](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515224303227.png)

但是！！这样是不对的  我们无法保证先销毁父类对象之后不调用父类，C++为了保证析构安全，在子类析构析构之后会自动调用父类析构函数

![image-20240515224907815](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515224907815.png)

![image-20240515224917151](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515224917151.png)

![image-20240515224925163](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240515224925163.png)