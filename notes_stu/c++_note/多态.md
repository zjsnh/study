# 多态

![image-20240516212657151](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240516212657151.png)

## 虚函数重写

**继承关系父子的两个虚函数，函数名，参数类型，返回值都相同才构成虚函数重写**

virtual只能修饰成员函数，用来构成多态

例外1：**协变：返回值可以不同，但返回值必须是父类或者子类的指针或者引用**，其他类也是可以的

例外2：子类虚函数重写可以不加virtual  （派生类）ps：建议加上

![image-20240516213541326](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240516213541326.png)

![image-20240516213412634](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240516213412634.png)

![image-20240516213321025](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240516213321025.png)

![image-20240516214150397](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240516214150397.png)

![image-20240516214137627](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240516214137627.png)

由于特殊处理，析构函数在被处理后，函数名相同，父类加上virtual就可以正确调用，防止内存泄漏！  

ps：p先是指向基类 后被赋值为基类   可以赋值的原因是他们是基类和派生类，由于指针并不会对不同的类进行处理，将导致，后面析构的时候，delete不会对派生类进行特殊处理而是直接调用基类析构函数

虚函数的重写，继承的是接口，重写实现

![image-20240520160041520](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520160041520.png)

 只有构成多态的时候，才是使用父类的接口，不构成多态的时候只是正常调用（父类的指针或者引用去调用）

![image-20240520161029113](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520161029113.png)

# final

![image-20240520161140775](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520161140775.png)

#  override

![image-20240520161342795](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520161342795.png)

# 抽象类

![image-20240520164323735](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520164323735.png)

![image-20240520163938566](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520163938566.png)

比如 动物类 无法实例出对象，但是可以让 例如 马类去继承 去实例化 马 而动物类具有的虚函数也就是 马 这个类必须重写或者是必须拥有这个虚函数 从而实现派生类之间的多态

![image-20240520164131981](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520164131981.png)

![image-20240520164239714](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520164239714.png)

![image-20240520164355621](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520164355621.png)

![image-20240520165016285](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520165016285.png)

只要有虚函数，就会有虚函数表 存放指针

![image-20240520165212783](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520165212783.png)

![image-20240520165645895](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520165645895.png)

# 多态的原理 

![image-20240520171005748](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520171005748.png)

 父类指针接收子类地址后，**会切割**，但是子类的虚函数表内指向的地址已经改变，而父类指向的虚函数表内地址并未改变，也就造成了多态

![image-20240520171401689](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520171401689.png)

多态调用会在虚函数表里去找到需要调用的函数地址，但是普通调用就直接确定调用地址

 ![image-20240520172514126](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520172514126.png)![image-20240520172448501](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520172448501.png)

如果子类没有重写父类虚函数，虚表也不一样

![image-20240520173027953](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520173027953.png)

同一个类的对象共用一个虚表

![image-20240520173156675](C:\Users\30780\AppData\Roaming\Typora\typora-user-images\image-20240520173156675.png)